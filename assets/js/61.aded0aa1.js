(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{428:function(t,e,a){"use strict";a.r(e);var r=a(25),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"wait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wait"}},[t._v("#")]),t._v(" Wait")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("编辑人(全网同名)："),a("strong",[a("strong",[t._v("酷酷的诚")])]),t._v("  邮箱："),a("strong",[t._v("zhangchengk@foxmail.com")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),a("p",[t._v("将传入的FlowFiles路由到“wait”关系，直到从相应的Notify处理器将匹配的释放信号存储在分布式缓存中为止。 当识别到匹配的释放信号时，等待的FlowFile被路由到“success”关系，具有从FlowFile复制的属性，这些属性从Notify处理器生成了释放信号。 然后从缓存中删除释放信号条目。如果等待的FlowFiles超过了Expireation Duration，它们将被路由到“expired”。 如果需要等待多个信号，请通过'Target Signal Count'（Target Signal Count）属性指定所需的信号数。 这对于将源FlowFile分成多个片段的处理器（例如SplitText）特别有用。 为了等待所有片段被处理，请将“original”关系连接到Wait处理器，并将'splits'关系连接到相应的通知处理器。将'${fragment.identifier}'配置到Notify和Wait的'Release Signal Identifier'，将'${fragment.count}'配置到Wait的'Target Signal Count'。 当使用“wait”关系作为循环时，建议使用优先级排序器（例如先进先出）。")]),t._v(" "),a("h2",{attrs:{id:"属性配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性配置"}},[t._v("#")]),t._v(" 属性配置")]),t._v(" "),a("p",[t._v("在下面的列表中，必需属性的名称以粗体显示。任何其他属性(不是粗体)都被认为是可选的，并且指出属性默认值（如果有默认值），以及属性是否支持表达式语言。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Name")]),t._v(" "),a("th",[t._v("Default Value")]),t._v(" "),a("th",[t._v("Allowable Values")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[t._v("Release Signal Identifier")])]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("值或根据FlowFile和属性表达式语言计算的结果，以确定释放信号缓存键 "),a("br"),a("strong",[t._v("Supports Expression Language: true (will be evaluated using flow file attributes and variable registry)")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Target Signal Count")])]),t._v(" "),a("td",[t._v("1")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("值或根据FlowFile和属性表达式语言计算的结果，以确定目标信号计数。该处理器检查信号计数是否已达到此数目。 如果指定了信号计数器名称，则该处理器检查特定的计数器，否则检查信号中的总计数。"),a("br"),t._v(" "),a("strong",[t._v("Supports Expression Language: true (will be evaluated using flow file attributes and variable registry)")])])]),t._v(" "),a("tr",[a("td",[t._v("Signal Counter Name")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("值或根据FlowFile和属性表达式语言计算的结果，以确定信号计数器名称。如果未指定，则此处理器检查信号中的总数。"),a("br"),a("strong",[t._v("Supports Expression Language: true (will be evaluated using flow file attributes and variable registry)")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Wait Buffer Count")])]),t._v(" "),a("td",[t._v("1")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("指定可以缓冲以检查其是否可以向前移动的最大传入FlowFiles数。 更多的缓冲区可以提供更好的性能，因为它通过按信号标识符对FlowFiles进行分组来减少与缓存服务的交互次数。 在处理器执行时只能处理信号标识符。")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Releasable FlowFile Count")])]),t._v(" "),a("td",[t._v("1")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("值或根据FlowFile和属性表达式语言计算的结果，以确定可释放的FlowFile计数。这指定当目标计数达到目标信号计数时可以释放多少个FlowFiles。零（0）具有特殊含义，只要信号计数与目标匹配，就可以释放任意数量的FlowFile。 "),a("br"),a("strong",[t._v("Supports Expression Language: true (will be evaluated using flow file attributes and variable registry)")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Expiration Duration")])]),t._v(" "),a("td",[t._v("10 min")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("指示等待的FlowFiles将被路由到“expired”关系的持续时间")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Distributed Cache Service")])]),t._v(" "),a("td"),t._v(" "),a("td",[a("strong",[t._v("Controller Service API:")]),t._v(" "),a("br"),t._v(" AtomicDistributedMapCacheClient"),a("br"),t._v(" **Implementations:**CouchbaseMapCacheClient"),a("br"),t._v("RedisDistributedMapCacheClientService"),a("br"),t._v("DistributedMapCacheClientService"),a("br"),t._v("HBase_1_1_2_ClientMapCacheService"),a("br"),t._v("HBase_2_ClientMapCacheService")]),t._v(" "),a("td",[t._v("控制器服务，用于检查来自相应通知处理器的释放信号")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Attribute Copy Mode")])]),t._v(" "),a("td",[t._v("keeporiginal")]),t._v(" "),a("td",[t._v("* Replace if present "),a("br"),t._v("* Keep original")]),t._v(" "),a("td",[t._v("指定如何处理从FlowFiles复制到进入Notify处理器的属性")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("Wait Mode")])]),t._v(" "),a("td",[t._v("wait")]),t._v(" "),a("td",[t._v("* Transfer to wait relationship "),a("br"),t._v("* Keep in the upstream connection")]),t._v(" "),a("td",[t._v("指定如何处理等待通知信号的FlowFile")])]),t._v(" "),a("tr",[a("td",[t._v("Wait Penalty Duration")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("如果进行了配置，则在处理完信号标识符但不满足发布标准后，该信号标识符将受到处罚，并且具有信号标识符的FlowFiles将在指定的时间段内不再进行处理，因此该信号标识符将不会阻止其他对象被处理。这对于需要等待处理器来处理多个信号标识符，并且每个信号标识符具有多个FlowFiles，并且在信号标识符中释放FlowFiles的顺序很重要的用例很有用。可以使用优先级排序器配置FlowFile顺序。重要说明：可以处理排队信号的数量受到限制，并且等待处理器可能无法检查所有排队信号ID。请参阅其他详细信息，以获取最佳实践。")])])])]),t._v(" "),a("h2",{attrs:{id:"连接关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接关系"}},[t._v("#")]),t._v(" 连接关系")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Name")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("expired")]),t._v(" "),a("td",[t._v("超过配置的有效期限的FlowFile将被路由到此关系")])]),t._v(" "),a("tr",[a("td",[t._v("success")]),t._v(" "),a("td",[t._v("在缓存中具有匹​​配释放信号的FlowFile将被路由到此关系")])]),t._v(" "),a("tr",[a("td",[t._v("wait")]),t._v(" "),a("td",[t._v("缓存中没有匹配释放信号的FlowFile将被路由到此关系")])]),t._v(" "),a("tr",[a("td",[t._v("failure")]),t._v(" "),a("td",[t._v("当无法访问缓存时，或者如果Release Signal Identifier计算的值为null或为空，则FlowFiles将被路由到该关系")])])])]),t._v(" "),a("h2",{attrs:{id:"自定义连接关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义连接关系"}},[t._v("#")]),t._v(" 自定义连接关系")]),t._v(" "),a("h2",{attrs:{id:"读取属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读取属性"}},[t._v("#")]),t._v(" 读取属性")]),t._v(" "),a("p",[t._v("没有指定。")]),t._v(" "),a("h2",{attrs:{id:"写属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写属性"}},[t._v("#")]),t._v(" 写属性")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Name")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("wait.start.timestamp")]),t._v(" "),a("td",[t._v("所有FlowFiles都将具有“wait.start.timestamp”属性，该属性设置文件首次进入此处理器时的初始时期时间戳。这用于确定FlowFile的到期时间。当FlowFile转移到失败或成功时，不会写入此属性")])]),t._v(" "),a("tr",[a("td",[t._v("wait.counter."),a("code",[t._v("<counterName>")])]),t._v(" "),a("td",[t._v("如果处理器运行时存在信号，则将复制信号中的每个计数值。")])])])]),t._v(" "),a("h2",{attrs:{id:"状态管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态管理"}},[t._v("#")]),t._v(" 状态管理")]),t._v(" "),a("p",[t._v("此组件不存储状态。")]),t._v(" "),a("h2",{attrs:{id:"限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[t._v("#")]),t._v(" 限制")]),t._v(" "),a("p",[t._v("此组件不受限制。")]),t._v(" "),a("h2",{attrs:{id:"输入要求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入要求"}},[t._v("#")]),t._v(" 输入要求")]),t._v(" "),a("p",[t._v("此组件需要传入关系。")]),t._v(" "),a("h2",{attrs:{id:"系统资源方面的考虑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统资源方面的考虑"}},[t._v("#")]),t._v(" 系统资源方面的考虑")]),t._v(" "),a("p",[t._v("没有指定。")]),t._v(" "),a("h2",{attrs:{id:"公众号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#公众号"}},[t._v("#")]),t._v(" 公众号")]),t._v(" "),a("p",[t._v("关注公众号 得到第一手文章/文档更新推送。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://nifichina.gitee.io/image/donate/wechat.jpg",alt:""}})])])}),[],!1,null,null,null);e.default=v.exports}}]);